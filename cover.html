
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gophermart: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/brotigen23/gopherMart/cmd/gophermart/main.go (0.0%)</option>
				
				<option value="file1">github.com/brotigen23/gopherMart/internal/app/app.go (0.0%)</option>
				
				<option value="file2">github.com/brotigen23/gopherMart/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/brotigen23/gopherMart/internal/database/migration.go (0.0%)</option>
				
				<option value="file4">github.com/brotigen23/gopherMart/internal/handler/userHandler.go (66.7%)</option>
				
				<option value="file5">github.com/brotigen23/gopherMart/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file6">github.com/brotigen23/gopherMart/internal/middleware/gzip.go (0.0%)</option>
				
				<option value="file7">github.com/brotigen23/gopherMart/internal/middleware/logging.go (0.0%)</option>
				
				<option value="file8">github.com/brotigen23/gopherMart/internal/server/server.go (0.0%)</option>
				
				<option value="file9">github.com/brotigen23/gopherMart/internal/service/userService.go (100.0%)</option>
				
				<option value="file10">github.com/brotigen23/gopherMart/internal/utils/utils.go (30.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "github.com/brotigen23/gopherMart/internal/app"

func main() <span class="cov0" title="0">{
        app.Run(":8080")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "github.com/brotigen23/gopherMart/internal/config"
        "github.com/brotigen23/gopherMart/internal/server"
)

func Run(serverAddr string) error <span class="cov0" title="0">{
        config, err := config.NewConfig("config.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">server := server.NewServer(config)
        err = server.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"

        "gopkg.in/yaml.v2"
)

type Config struct {
        Server struct {
                Port string `yaml:"port" env:"PORT" env-default:"8080"`
                Host string `yaml:"host" env:"PORT" env-default:"8080"`
        } `yaml:"server"`

        Database struct {
                Username string `yaml:"user"`
                Password string `yaml:"pass"`
        } `yaml:"database"`

        JWTSecretKey string `yaml:"secret_key"`
}

func NewConfig(filePath string) (*Config, error) <span class="cov0" title="0">{
        f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        var cfg *Config
        decoder := yaml.NewDecoder(f)
        err = decoder.Decode(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "database/sql"
        "embed"
        "errors"
        "fmt"

        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        "github.com/golang-migrate/migrate/v4/source"
        "github.com/golang-migrate/migrate/v4/source/iofs"
)

// Migrator —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –º–∏–≥—Ä–∞—Ü–∏–π.
type Migrator struct {
        srcDriver source.Driver // –î—Ä–∞–π–≤–µ—Ä –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –º–∏–≥—Ä–∞—Ü–∏–π.
}

// MustGetNewMigrator —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä Migrator —Å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º–∏ SQL-—Ñ–∞–π–ª–∞–º–∏ –º–∏–≥—Ä–∞—Ü–∏–π.
// –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤—ã–∑—ã–≤–∞–µ—Ç panic.
func MustGetNewMigrator(sqlFiles embed.FS, dirName string) *Migrator <span class="cov0" title="0">{
        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –¥—Ä–∞–π–≤–µ—Ä –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –º–∏–≥—Ä–∞—Ü–∏–π —Å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º–∏ SQL-—Ñ–∞–π–ª–∞–º–∏.
        d, err := iofs.New(sqlFiles, dirName)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;Migrator{
                srcDriver: d,
        }</span>
}

// ApplyMigrations –ø—Ä–∏–º–µ–Ω—è–µ—Ç –º–∏–≥—Ä–∞—Ü–∏–∏ –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.
func (m *Migrator) ApplyMigrations(db *sql.DB) error <span class="cov0" title="0">{
        // –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –¥—Ä–∞–π–≤–µ—Ä–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è PostgreSQL.
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create db instance: %v", err)
        }</span>

        // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –º–∏–≥—Ä–∞—Ç–æ—Ä–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –¥—Ä–∞–π–≤–µ—Ä–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –∏ –¥—Ä–∞–π–≤–µ—Ä–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö PostgreSQL.
        <span class="cov0" title="0">migrator, err := migrate.NewWithInstance("migration_embeded_sql_files", m.srcDriver, "psql_db", driver)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to create migration: %v", err)
        }</span>

        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –º–∏–≥—Ä–∞—Ç–æ—Ä –≤ –∫–æ–Ω—Ü–µ —Ä–∞–±–æ—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏.
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                migrator.Close()
        }</span>()

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–∏–≥—Ä–∞—Ü–∏–∏.
        <span class="cov0" title="0">if err = migrator.Up(); err != nil &amp;&amp; !errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to apply migrations %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "bytes"
        "encoding/json"
        "io"
        "log"
        "net/http"
        "time"

        "github.com/brotigen23/gopherMart/internal/config"
        "github.com/brotigen23/gopherMart/internal/dto"
        "github.com/brotigen23/gopherMart/internal/service"
        "github.com/brotigen23/gopherMart/internal/utils"
)

type userHandler struct {
        Config *config.Config

        userService *service.UserService
}

func NewUserHandler(config *config.Config) *userHandler <span class="cov8" title="1">{
        return &amp;userHandler{
                Config:      config,
                userService: service.NewUserService(),
        }
}</span>

func unmarhallUser(r io.ReadCloser) (*dto.User, error) <span class="cov8" title="1">{
        var user dto.User
        var buffer bytes.Buffer
        _, err := buffer.ReadFrom(r)
        if err != nil </span><span class="cov0" title="0">{
                // TODO: –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É
                log.Printf("error: %v", err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">if err = json.Unmarshal(buffer.Bytes(), &amp;user); err != nil </span><span class="cov0" title="0">{
                log.Printf("error: %v", err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;user, nil</span>
}

func (h *userHandler) Register(rw http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        user, err := unmarhallUser(r.Body)
</span>        if err != nil {
                http.Error(rw, "server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">// –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–æ–≥–∏–Ω–∞ –≤ –ë–î
        if h.userServi</span><span class="cov0" title="0">ce.IsUserExists(user.Login) {
                // TODO: –£–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                return
        }

</span>        // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å –≤ –ë–î
        err = h.userService.Save(user.Login, user.Password)
        <span class="cov8" title="1">if err != nil {
</span>                log.Printf("error: %v", err.Error())
                return
        }</span>

        // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
        <span class="cov8" title="1">expires := time.Minute * 15
        // TODO: –≤—ã–</span><span class="cov0" title="0">Ω–µ—Å—Ç–∏ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
        JWTSecretKey := "secret_key"
        jwtString, err := utils.BuildJWTString(user.Login, JWTSecretKey, expires)
        i</span>f err != nil {
                log.Printf("error: %v", err.Error())
                return
        <span class="cov8" title="1">}

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –±–∞–∑—É
        cookie := &amp;http.Cookie{
                Name:  "token</span><span class="cov0" title="0">",
                Value: jwtString,
        }
        r</span>.AddCookie(cookie)
        http.SetCookie(rw, cookie)
        rw.WriteHeader(http.StatusOK)
}<span class="cov8" title="1">

func (h *userHandler) Login(rw http.ResponseWriter, r *http.Request) {
        user, err := unmarhallUser(r.Body)
        if err != nil {
                http.Error(rw, "server error", http.StatusInternalServerError)
                return
</span>        }
        //* –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–æ–≥–∏–Ω–∞ –≤ –ë–î –∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤–≤–µ–¥–µ–Ω–Ω–æ–≥–æ –ø–∞—Ä–æ–ª—è
        if h.userService.IsUserExists(user.Login) {
                // TODO: –ï—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
                return
        }

        // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
        expires := time.Minute * 15
        </span>// TODO: –≤—ã–Ω–µ—Å—Ç–∏ —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∫–ª—é—á –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
        JWTSecretKey := "secret_key"
        jwtString, err := utils.BuildJWTString(user.Login, JWTSecretKey, expires)<span class="cov0" title="0">
        if err != nil {
        </span>        log.Printf("error: %v", err.Error())
                return
        }

        </span>// –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –±–∞–∑—É
        cookie := &amp;http.Cookie{
                Name:  "token",
                Value: jwtString,
        </span>}
        r.AddCookie(cookie)
        http.SetCookie(rw, cookie)
        rw.WriteHeader(http.StatusOK)
}</span>

func (h *userHandler) SaveOrder(rw http.ResponseWriter, r *http.Request) {

}</span>

func (h *userHandler) GetOrders(rw http.ResponseWriter, r *http.Request) {

}

func (h *userHandler) GetBalance(rw http.ResponseWriter, r *http.Request) {

}

func (h *userHandler) Withdraw(rw http.ResponseWriter, r *http.Request) {

}

func (h *userHandler) GetWithDrawals(rw http.ResponseWriter, r *http.Request) {

}
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "log"
        "net/http"

        "github.com/brotigen23/gopherMart/internal/utils"
)

const JWTSecretKey = "secret_key"

func Auth(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                cookie, err := r.Cookie("token")
                if err != nil {
                        log.Println(err.Error())
                        http.Error(rw, err.Error(), http.StatusUnauthorized)
                        return
</span>                }
                // * –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ —Ç–æ —Ç–æ–∫–µ–Ω –Ω–µ–ø–æ–Ω—è—Ç–Ω—ã–π, –∏–Ω–∞—á–µ –≤—Å–µ –Ω–æ—Ä–º
                _, err = utils.GetUserLoginFromJWT(cookie.Value, JWTSecretKey)
                i</span>f err != nil {
                <span class="cov0" title="0">        log.Println(err.Error())
                        http.Error(rw</span><span class="cov0" title="0">, err.Error(), http.StatusUnauthorized)
                        return
                }
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import "net/http"

func Gzip(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                next.ServeHTTP(rw, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "log"
        "net/http"
        "time"
)

func Log(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                timeStart := time.Now()
                next.ServeHTTP(w, r)
                log.Printf("Time to response: %v", time.Since(timeStart))
        }</span>)
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package server

import (
        "log"
        "net/http"

        "github.com/brotigen23/gopherMart/internal/config"
        "github.com/brotigen23/gopherMart/internal/handler"
        "github.com/brotigen23/gopherMart/internal/middleware"
        "github.com/go-chi/chi"
        chiMiddleware "github.com/go-chi/chi/middleware"
)

type Server struct {
        config *config.Config
}

func NewServer(config *config.Config) *Server <span class="cov0" title="0">{
        return &amp;Server{
                config: config,
        }
}</span>

func (s Server) Run() error <span class="cov0" title="0">{
        log.Println("Server is running")

        // TODO: —Å–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î
        log.Println("DB")

        // TODO: –º–∏–≥—Ä–∞—Ü–∏—è –ë–î

        // TODO: —Å–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–æ–≤
        log.Println("Services")
        // TODO: —Å–æ–∑–¥–∞–Ω–∏–µ —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤
        log.Println("Handlers")
        userHandler := handler.NewUserHandler(nil)

        // TODO: —Å–æ–∑–¥–∞–Ω–∏–µ —Ä–æ—É—Ç–µ—Ä–∞
        log.Println("Router")
        router := chi.NewRouter()
        router.Use(chiMiddleware.Logger)
        router.Use(chiMiddleware.Compress(3, "plain/text", "application/json"))

        router.With(middleware.ValidateUser).Post("/api/user/register", userHandler.Register)
        router.With(middleware.ValidateUser).Post("/api/user/login", userHandler.Login)

        router.With(middleware.Auth).Post("/api/user/orders", userHandler.SaveOrder)
        router.With(middleware.Auth).Get("/api/user/orders", userHandler.GetOrders)

        router.With(middleware.Auth).Get("/api/user/balance", userHandler.GetBalance)
        router.With(middleware.Auth).Post("/api/user/balance/withdraw", userHandler.Withdraw)

        router.With(middleware.Auth).Get("/api/user/withdrawals", userHandler.GetWithDrawals)

        serv := &amp;http.Server{
                Addr:    s.config.Server.Host + ":" + s.config.Server.Port,
                Handler: router,
        }

        return serv.ListenAndServe()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package service

type UserService struct {
        // TODO: –ë–î
        // * –õ–æ–≥–≥–µ—Ä –¥–ª—è –æ—à–∏–±–æ–∫
}

func NewUserService() *UserService <span class="cov8" title="1">{
        return &amp;UserService{}
}</span>

func (s *UserService) IsUserExists(login string) bool <span class="cov8" title="1">{
        return false
}</span>

func (s *UserService) Save(login string, password string) error <span class="cov8" title="1">{
        // * –í–æ–∑–º–æ–∂–Ω–æ —Å—Ç–æ–∏—Ç –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä–æ–ª—å
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package utils

import (
        "fmt"
        "time"

        "github.com/golang-jwt/jwt/v4"
)

type UserJWTClaims struct {
        jwt.RegisteredClaims
        Login string
}

func BuildJWTString(login string, key string, expires time.Duration) (string, error) <span class="cov8" title="1">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, &amp;UserJWTClaims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(expires)),
                },
                Login: login,
        })

        tokenString, err := token.SignedString([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return tokenString, nil</span>
}

func GetUserLoginFromJWT(tokenString string, key string) (string, error) <span class="cov0" title="0">{
        claims := &amp;UserJWTClaims{}
        token, err := jwt.ParseWithClaims(tokenString, claims,
                func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(key), nil
                }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                return "", fmt.Errorf("token is invalid")
        }</span>

        <span class="cov0" title="0">return claims.Login, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
